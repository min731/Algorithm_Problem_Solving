def solution(n, times):

    # times.sort()
    #커봤자 e 는 최소 곱하기 n
    e = times[0] * n
    s = 0
    while s<=e: 
        m = (s+e)//2
        #중간값 m
        S = 0
        #S는 m안에 몇명이 들어가는지
        piv = int(1e9)
        #piv는 나머지중에 가장 작은애(아래서 설명)
        for time in times:
            S +=  m//time
            #포문을돌면서 m이 정답이라고 가정했을때 해당심사관이 몇명을 처리했는지 더해줌
            if m%time <piv:
                piv = m%time
                """
                piv는 포문을 돌면서 나머지중에 가장 작은애
                예를 들면 문제에서 정답이 28일때 7,10,14,20,21,28로 6번째 사람이 딱 들어오면서
                끝남 근데 만약에 m이 29라고 하면 piv는 1이 남게됨, 그럼 1만큼 더 작아도 
                정답이므로(1만큼 더 작아도 S는 변하지 않음 만약에 딱 나눠 떨어지면 0이되겠져
                
                어 근데 님 m에서 piv만큼 빼다가 S가 달라지면 어카져 ? 29에서 2만큼 빼서 27이되면
                7로나눈게 4가 아니라 3이 되잖아여 >>> 애초에 m을 time으로 나눈 나머지들 중 최소
                이기 때문에 그만큼 빼도 몫이 달라질 일이 없음 
                """
        if S == n:
            return m-piv
            """
            그래서 각 심사관이 처리한 인원들을 다 더했는데 n과 같다면
            우리가 오바해서 센 piv만큼 빼주는것이 답
            """
        #아래는 그냥 이분탐색
        elif S>=n:
            e=m-1
        else:
            s=m+1
    return s